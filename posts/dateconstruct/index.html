<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>DataConstruct | hjxblog</title>

    
<link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" />




<meta name="author" content="felixhe" />
<meta name="description" content="稀疏数组 当一个数组中包含大量零的元素时，使用原完整数组会浪费内存以及消耗运行时间，可以转换为稀疏数组来实现减小内存，加快运行速度 稀疏数组组成" />



<meta name="generator" content="Hugo 0.60.1" />

<link rel="canonical" href="https://felixhjx.github.io/posts/dateconstruct/" />


<meta property="og:title" content="DataConstruct" />
<meta property="og:description" content="稀疏数组 当一个数组中包含大量零的元素时，使用原完整数组会浪费内存以及消耗运行时间，可以转换为稀疏数组来实现减小内存，加快运行速度 稀疏数组组成" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://felixhjx.github.io/posts/dateconstruct/" />
<meta property="og:image" content="https://felixhjx.github.io/background1.jpg"/>
<meta property="article:published_time" content="2022-05-20T09:48:58+08:00" />
<meta property="article:modified_time" content="2022-05-20T09:48:58+08:00" />



<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://felixhjx.github.io/background1.jpg"/>

<meta name="twitter:title" content="DataConstruct"/>
<meta name="twitter:description" content="稀疏数组 当一个数组中包含大量零的元素时，使用原完整数组会浪费内存以及消耗运行时间，可以转换为稀疏数组来实现减小内存，加快运行速度 稀疏数组组成"/>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" integrity="sha256-UXesixbeLkB/UYxVTzuj/gg3+LMzgwAmg3zD+C4ZASQ=" crossorigin="anonymous">
<link rel="stylesheet" href="/css/icomoon.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/overlayscrollbars@1.13.1/css/OverlayScrollbars.min.css" integrity="sha256-WKijf8KI68sbq8Znd6yMepIuFF0wdWfIt6gk3JWcQfk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css">
<link rel="stylesheet" href="/css/site.css" />

<style>
  .ui.header a:not(.item, .ui.button):hover {
    text-decoration: underline;
  }

  
  a:not(.item, .ui.button) {
    color: seagreen !important;
  }
  

  
  .inverted a:not(.item, .ui.button) {
     color: darkseagreen !important;
  }
  

  
  body.default {
    
    background-color: #fff;
    

    
    background-image: url(me/background1.jpg);
    
  }
  

  
  body.dark {
    
    background-color: #333;
    

    
    background-image: url(/me/background1.jpg);
    
  }
  
</style>


    



<link rel="stylesheet" data-highlight href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/tomorrow.min.css" />







    
    <link rel="stylesheet" href="/css/custom.css" />
    
  </head>

  <body class="default">
    
<nav class="ui secondary menu dream-menu dream-nav">

  <a class="item dream-flip-toggle" title="翻转！">
    <i class="large link bullseye icon"></i>
  </a>
  <a class="item" href="https://felixhjx.github.io/" title="首页">
    <i class="large link home icon"></i>
  </a>
  
  <a class="item" onclick="themeSwitch(event)">
    <i class="large link icon theme-switch"></i>
  </a>
  
  
  <a class="item" title="搜索" onclick="toggleSearch(event)">
    <i class="large link search icon"></i>
  </a>
  
</nav>

    <div class="flip-container">
      <div class="flipper">
        <section class="front">
          <div class="dream-max-width">
            
<div class="ui relaxed centered grid dream-grid dream-grid-single">
  
  
  
  

  
  <aside class="sixteen wide mobile sixteen wide tablet three wide computer column dream-single-aside">
    
    <div class="ui segment toc">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#heading1">稀疏数组组成</a></li>
    <li><a href="#heading2">稀疏数组代码实现</a></li>
  </ul>

  <ul>
    <li><a href="#heading4">数组模拟队列</a></li>
    <li><a href="#heading5">环形队列</a></li>
  </ul>

  <ul>
    <li><a href="#heading7">顺序表</a>
      <ul>
        <li><a href="#heading8">顺序表的定义</a></li>
        <li><a href="#heading9">顺序存储结构</a></li>
        <li><a href="#heading10">顺序表的插入与删除</a></li>
      </ul>
    </li>
    <li><a href="#heading11">单链表</a>
      <ul>
        <li><a href="#heading12">链式存储结构</a></li>
        <li><a href="#heading13">单链表操作</a></li>
      </ul>
    </li>
    <li><a href="#loop-linklist">Loop Linklist</a></li>
    <li><a href="#heading27">双链表</a></li>
    <li><a href="#heading28">双向链表</a></li>
    <li><a href="#heading29">线性表的应用</a></li>
    <li><a href="#heading30">练习</a></li>
  </ul>

  <ul>
    <li><a href="#heading31">栈的操作</a></li>
    <li><a href="#heading32">表达式问题</a></li>
  </ul>

  <ul>
    <li><a href="#heading33">输出序列问题</a></li>
  </ul>

  <ul>
    <li><a href="#heading36">稀疏矩阵</a></li>
  </ul>

  <ul>
    <li><a href="#heading38">二叉树</a></li>
    <li><a href="#heading39">二叉排序树</a></li>
    <li><a href="#heading40">平衡二叉树</a>
      <ul>
        <li><a href="#heading41">失衡二叉树的分析与调整</a></li>
      </ul>
    </li>
    <li><a href="#huffman-tree">哈夫曼树（Huffman Tree）</a></li>
  </ul>

  <ul>
    <li><a href="#heading43">图的储存结构</a>
      <ul>
        <li><a href="#heading44">领阶矩阵顺序存储</a></li>
        <li><a href="#heading45">领接表</a></li>
      </ul>
    </li>
    <li><a href="#heading46">图的遍历</a>
      <ul>
        <li><a href="#dfs">深度优先搜索遍历DFS</a></li>
        <li><a href="#bfs">广度优先搜索遍历BFS</a></li>
      </ul>
    </li>
    <li><a href="#heading47">最小生成树</a>
      <ul>
        <li><a href="#prim">prim算法（普利姆）</a></li>
        <li><a href="#kruskal">kruskal克鲁斯卡尔算法</a></li>
      </ul>
    </li>
    <li><a href="#heading48">最短路径</a></li>
  </ul>

  <ul>
    <li><a href="#heading50">快速排序</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#hash-table">Hash Table</a></li>
      </ul>
    </li>
    <li><a href="#hash-function">构造hash function的方法</a></li>
    <li><a href="#heading52">解决冲突问题</a></li>
  </ul>

  <ul>
    <li><a href="#leetcode-base">LeetCode base</a></li>
    <li><a href="#heading53">哨兵结点问题</a></li>
  </ul>
</nav>
    </div>
    

    
  </aside>
  
  <div class="sixteen wide mobile sixteen wide tablet ten wide computer column markdown-body dream-single" id="dream-save-post-as-img">
    <section class="ui segment">
      <header>
        <h1 class="ui large header">DataConstruct<span class="sub header">
            <span class="left">
              @
              
                
                  felixhe
                
              

              | 
                  <span data-format="luxon">2022-05-20T09:48:58&#43;08:00</span>
                

              | 20 分钟阅读

              
              | 更新于
                
                  <span data-format="luxon">2022-05-20T09:48:58&#43;08:00</span>
                
              
            </span>

            
            <span class="dream-share">
  <a href="#" class="save-as-image" title="保存为图片" onclick="savePostAsImg()">
    <i class="save icon"></i>
  </a>
  <a href="https://twitter.com/intent/tweet?text=DataConstruct&url=https%3a%2f%2ffelixhjx.github.io%2fposts%2fdateconstruct%2f" title="Twitter">
    <i class="twitter icon"></i>
  </a>
  <a href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ffelixhjx.github.io%2fposts%2fdateconstruct%2f" title="Facebook">
    <i class="facebook icon"></i>
  </a>
</span>

            
          </span>
        </h1>
      </header>

      <article class="main">
        
        <img class="cover" src="https://s1.ax1x.com/2022/05/20/OOmJMQ.jpg" />
        

        <h1 id="heading">稀疏数组</h1>
<p>当一个数组中包含大量零的元素时，使用原完整数组会浪费内存以及消耗运行时间，可以转换为稀疏数组来实现减小内存，加快运行速度</p>
<h2 id="heading1">稀疏数组组成</h2>
<p>由三列多行组成 第一行记录</p>
<p>行值｜列值｜元素值</p>
<h2 id="heading2">稀疏数组代码实现</h2>
<pre><code>package Sparse;

/**当数组中大量数据为零时，转换为稀疏数组减小内存
 * 稀疏数组
 * 组成三列多行
 * 第一行记录几行 几列 值的个数
 * 后面依次记录每个数据
 *
 * 数组转稀疏数组
 * 1 遍历数组获取有效元素个数
 * 2 根据有效元素个数创建几行的稀疏数组
 */
public class sparseArray {
    public static void main(String[] args) {
        //定义11*11数组
        int chessArray1[][]=new int[11][11];
        chessArray1[1][2]=1;
        chessArray1[2][3]=2;
        chessArray1[5][8]=6;
        //数组输出
        System.out.println(&quot;原始二维数组&quot;);
        for (int[] row:chessArray1){
            for (int data:row){
                System.out.printf(&quot;%d\t&quot;,data);
            }
            System.out.println();
        }
        //获取元素个数
        int sum=0;
        for (int i = 0; i &lt;chessArray1.length ; i++) {
            for (int j = 0; j &lt;chessArray1.length ; j++) {
                if(chessArray1[i][j]!=0)
                    sum++;
            }
        }
        System.out.println(&quot;sum= &quot;+sum);
        //创建稀疏数组
        int[][] spareArray=new int[sum+1][3];
        spareArray[0][0]=chessArray1.length;
        spareArray[0][1]=chessArray1.length;
        spareArray[0][2]=sum;
        //遍历二维数组将值传入稀疏数组
        int count=0;
        for (int i = 0; i &lt;chessArray1.length ; i++) {
            for (int j = 0; j &lt;chessArray1.length; j++) {
                if(chessArray1[i][j]!=0) {
                    count++;
                    //遍历二维数组，找到不为零的数据，i=行，j=列
                    spareArray[count][0]=i;
                    spareArray[count][1]=j;
                    spareArray[count][2]=chessArray1[i][j];
                }
            }
        }
        //输出稀疏数组

        for (int i = 0; i &lt;spareArray.length ; i++) {
            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;,spareArray[i][0],spareArray[i][1],spareArray[i][2]);
        }
        //将稀疏数组恢复成原二维数组
        int[][] chessArray2=new int[spareArray[0][0]][spareArray[0][1]];
        //遍历稀疏数组
        for (int i = 1; i &lt;spareArray.length ; i++) {
            chessArray2[spareArray[i][0]][spareArray[i][1]]=spareArray[i][2];
        }
        System.out.println();
        System.out.println(&quot;还原后的二维数组&quot;);
        for (int[] row:chessArray2){
            for (int data:row){
                System.out.printf(&quot;%d\t&quot;,data);
            }
            System.out.println();
        }
    }
}
</code></pre><h1 id="heading3">队列</h1>
<p>队列只允许在一端进行插入操作，而在另一端进行删除操作的线性表。 定义rear队列底，front队列顶，向队列中添加元素要先判断队列是否为满</p>
<p><strong>队列初始时刻</strong></p>
<p>由于队列只能一端进行添加删除操作，所以初始时刻rear=front=-1（-1是因为数组初始元素是从0开始，队列当添加进入一个元素+1之后才是0）</p>
<p>（Maxsize=front）</p>
<h2 id="heading4">数组模拟队列</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">package</span> queue<span style="color:#f92672">;</span>

<span style="color:#f92672">import</span> java.util.Scanner<span style="color:#f92672">;</span>

<span style="color:#75715e">//使用数组模拟队列
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">arrayQueue</span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">;</span><span style="color:#75715e">//数组最大容量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> front<span style="color:#f92672">;</span><span style="color:#75715e">//队列头
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> rear<span style="color:#f92672">;</span><span style="color:#75715e">//队列尾
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#f92672">]</span> array<span style="color:#f92672">;</span>

    <span style="color:#75715e">//创建队列的构造器
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">arrayQueue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> arrayMaxSize<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        maxSize<span style="color:#f92672">=</span>arrayMaxSize<span style="color:#f92672">;</span>
        array <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>maxSize<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
        front <span style="color:#f92672">=</span><span style="color:#f92672">-</span>1<span style="color:#f92672">;</span><span style="color:#75715e">//指向队列头的前一个位置
</span><span style="color:#75715e"></span>        rear <span style="color:#f92672">=</span><span style="color:#f92672">-</span>1<span style="color:#f92672">;</span><span style="color:#75715e">//指向队列尾部
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    <span style="color:#75715e">//判断队列是否满
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isFull</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> rear<span style="color:#f92672">=</span><span style="color:#f92672">=</span>maxSize<span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">//判断队列是否为空
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> rear<span style="color:#f92672">=</span><span style="color:#f92672">=</span>front<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">//添加数据进入队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addQueue</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#75715e">//先判断队列是否满
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>isFull<span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;队列已满&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        rear<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">;</span>
        array<span style="color:#f92672">[</span>rear<span style="color:#f92672">]</span><span style="color:#f92672">=</span>n<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">//获取队列数据，出队列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getQueue</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;队列空，不能获取数据&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        front<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> array<span style="color:#f92672">[</span>front<span style="color:#f92672">]</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">//遍历数组
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">showQueue</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;队列为空&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">+</span><span style="color:#f92672">+</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">printf</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;array[%d]=%d\n&#34;</span><span style="color:#f92672">,</span>i<span style="color:#f92672">,</span>array<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ArrayQueue</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[</span><span style="color:#f92672">]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        arrayQueue arrayQueue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> arrayQueue<span style="color:#f92672">(</span>3<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">char</span> key<span style="color:#f92672">=</span><span style="color:#e6db74">&#39; &#39;</span><span style="color:#f92672">;</span>
        Scanner in <span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Scanner<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span><span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;s(show:显示队列&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;e(exit:退出程序&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a(add:往队列中加入数据&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;g(get:队列中取出数据&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;h(head:查看队列头部&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            key<span style="color:#f92672">=</span>in<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="heading5">环形队列</h2>
<p>数组模拟队列存在数组使用一次就不能使用，没有达到复用的效果。改进成环形队列可以实现复用</p>
<h1 id="heading6"></h1>
<h1 id="list">线性表（List）</h1>
<h2 id="heading7">顺序表</h2>
<h3 id="heading8">顺序表的定义</h3>
<h3 id="heading9">顺序存储结构</h3>
<p><strong>静态分配</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e">sq link 
</span><span style="color:#75715e">循序表的静态分配 
</span><span style="color:#75715e">*/</span>
<span style="color:#75715e">#</span><span style="color:#75715e">include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#</span><span style="color:#75715e">define Maxsize 10</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
	<span style="color:#66d9ef">int</span> data[Maxsize];<span style="color:#75715e">// define maxsize of sqlist 
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> length;<span style="color:#75715e">//define currently size of sqlist
</span><span style="color:#75715e"></span>}sqlist;

<span style="color:#75715e">//init function
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitList</span>(sqlist <span style="color:#f92672">&amp;</span>L){
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>Maxsize;i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>){
		L.data[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
	}
	L.length<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	sqlist L;
	InitList(L);
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>L.length;i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>){
		printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">data[%d]=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,i,L.data[i]);
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><strong>动态分配</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">//动态分配创建顺序表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
    ElemType <span style="color:#f92672">*</span>elem;
    <span style="color:#66d9ef">int</span> length;
}SqList;

L.elem<span style="color:#f92672">=</span>(ElemType<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(ElemType)<span style="color:#f92672">*</span>MAXSIZE);
</code></pre></div><p>maloc函数</p>
<p><strong>顺序表的特点</strong></p>
<ol>
<li>随机访问，即可以在O(1)时间内找到第i个元素</li>
<li>存储密度高，每个节点只存储数据元素，链表需要额外存储指针</li>
<li>拓展容量不方便（静态分配不能拓展，动态分配拓展长度的时间复杂度也比较高）</li>
<li>插入，删除操作不方便，需要移动大量元素</li>
</ol>
<h3 id="heading10">顺序表的插入与删除</h3>
<p><strong>顺序表地插入</strong></p>
<p>算法分析：插入位置后地每个元素向后移，空出插入位置</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">status <span style="color:#a6e22e">InsertElement</span>(Sqlist <span style="color:#f92672">&amp;</span>L,<span style="color:#66d9ef">int</span> p,<span style="color:#66d9ef">int</span> e){
	<span style="color:#75715e">//传入数值差错判断 
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(p<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">|</span><span style="color:#f92672">|</span>p<span style="color:#f92672">&gt;</span>L.length<span style="color:#f92672">|</span><span style="color:#f92672">|</span>L.length<span style="color:#f92672">=</span>Maxsize)
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i;i<span style="color:#f92672">=</span>L.n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span>p;i<span style="color:#f92672">-</span><span style="color:#f92672">-</span>)
		L.data[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>L.data[i];
	<span style="color:#75715e">//数值插入 根据findelement函数找到的位置p，把以后的元素向后	 //移动一位空出排位置插入 
</span><span style="color:#75715e"></span>	L.data[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>e;
	L.n<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>时间复杂度分析</p>
<p>analyze：删除位置i上的元素，该元素后的元素向前移动一位</p>
<ol>
<li>删除位置是否合法（1&lt;i&lt;n)</li>
<li>将第i+1-n位元素依次向前移动一个位置</li>
<li>表长-1</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status ListDelete <span style="color:#a6e22e">Sq</span>(Sqlist <span style="color:#f92672">&amp;</span>L,<span style="color:#66d9ef">int</span> i){
    <span style="color:#66d9ef">if</span>((i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">|</span><span style="color:#f92672">|</span>i<span style="color:#f92672">&gt;</span>L.length<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> ERRPR<span style="color:#960050;background-color:#1e0010">；</span><span style="color:#75715e">//输入i值不合法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span>L.length<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
        L.elem[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>L.elem[j];
    L.length<span style="color:#f92672">-</span><span style="color:#f92672">-</span>;
    <span style="color:#66d9ef">return</span> OK;
}
</code></pre></div><p><strong>顺序表的删除</strong></p>
<h2 id="heading11">单链表</h2>
<h3 id="heading12">链式存储结构</h3>
<p>为了表示每个数据元素ai与其直接后继元素ai+1之间的逻辑关系，a1 数据元素除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（直接后继的存储位置）</p>
<p><strong>结点（node）</strong></p>
<ul>
<li>数据域
<ul>
<li>储存数据元素信息的域</li>
</ul>
</li>
<li>指针域
<ul>
<li>储存直接后置位置的域</li>
</ul>
</li>
</ul>
<p>头节点与第一个结点</p>
<p>为了更方便地对链表进行操作，在单链表的第一个结点前附设一个结点（头节点），头节点是指向第一个结点地</p>
<h3 id="heading13">单链表操作</h3>
<h4 id="heading14">单链表结点定义</h4>
<pre><code>typedef struct LNode
{
	ElemType data;
	struct LNode *next;
}LNode，*LinkList;	//LinkList为指向结构体Lnode的指针类型，自己指向自己
</code></pre><h4 id="heading15">结点制作</h4>
<p>以二叉树结点为例</p>
<pre><code>BTNode *BT；
BT=(BTNode *)malloc(sizeof(BTNode));
</code></pre><h4 id="heading16">单链表的初始化</h4>
<ol>
<li>生成新节点，用头指针L指向头节点</li>
<li>头节点指针域置空</li>
</ol>
<pre><code>status InitList(LinkList &amp;L){
	L=new LNode 
	// or L=(LinkList)malloc(sizeof(LNode)); 此处LinkList是指针型
	//从内存中获得空间赋值给
	L-&gt;next=NULL;
	return OK;
}
//头节点判空
</code></pre><h4 id="heading17">单链表判空</h4>
<p>空表：表中无元素，但是头指针与头节点还在，则判断头指针域是否为空即可</p>
<pre><code>int ListEmpty(LinkList L){
	if(L-&gt;next)	//not empty
		return 0;
	else
		return 1;
}
</code></pre><h4 id="heading18">单链表的销毁</h4>
<p>algorithm analysis：</p>
<p>从 头指针开始，依次释放所有结点</p>
<pre><code>status DestroyList_L(LinkList &amp;L){

	Lnode *p;	//or LinkList p;
	while(L){
		p=L;	//将L头结点的指针域指向P
		L=L-&gt;next;	//指针指向下一结点
		free(p); //or delete p;	//删除结点的指针,此处使用free要对应申请空间使用malloc，delete对应new
		}
	return OK;
}
</code></pre><h4 id="heading19">清空单链表</h4>
<p>algorithm analysis：</p>
<p>链表仍存在，链表中无元素，成为空链表（头指针和头节点仍然存在）</p>
<pre><code>statuse ClearList(LinkList &amp;L){

	Lnode *p,*q;//定义两个结点指针	与销毁不同
	p=L-&gt;next;	//p指向首元结点，与销毁单链表不同（p=L，此处p指向的是头节点)
	while(p){
        q=P-&gt;next;//运行到最后一个，q指向空
        free p;
        p=q;//空指向p退出循环
    }
    L-&gt;next=NULL;//结束循环后，给头结点指针域为置空
    return OK;
}
</code></pre><p>销毁与清空算法分析：</p>
<p>销毁单链表</p>
<h4 id="heading20">求单链表的表长</h4>
<pre><code>int ListLength_L(LinkList L){
	LNode *p;
	p=L-&gt;next;
	i=0;
	while(p){
		i++;
		p=p-&gt;next;
	}
	return i;
}
</code></pre><p><strong>取值</strong></p>
<p>从链表的头指针出发，顺着next逐个结点往下搜索，直到搜索到第i个结点（链表不是随机存取结构）</p>
<pre><code>status GetElem_L(LinkList L,int i,ELemType &amp;e){
	p=l-&gt;next;
	j=1;
	while(p&amp;&amp;j&lt;i){	//值判断
		p=p-&gt;next;
		++j;
	}
	if(!p||j&gt;1)
		return ERROR;
	e=p-&gt;data;
	return OK;
}
</code></pre><h4 id="heading21">按值查找</h4>
<p>返回值的地址</p>
<pre><code>LNode *LocateElem_L(LinkList L,Elemtype e){
	p=L-&gt;next;
	while(p&amp;&amp;p-&gt;data!=e){
		p=p-&gt;next;
	}
	return p;
}
</code></pre><p>返回位置序号</p>
<pre><code>int LocateElem_L(LinkList L,Elemtype e){
	p=L-&gt;next;
	j=1;
	while(p&amp;&amp;p-&gt;data!=e){//找到情况指针变量指向找到的结点
		p=p-&gt;next;		 //没找到指针变量为空，根究指针变量的值判断是否找到
		j++;
	}
	if(p){
		return j;
	}else
		return 0;
}
</code></pre><p>O(n) 最好情况知执行循环一次，最坏情况执行n次</p>
<h4 id="heading22">插入操作</h4>
<p>在第i个结点前插入值为e的新结点</p>
<p>algorithm analysis</p>
<pre><code>Status listInsert_L(LinkList &amp;L,int i,ElemType e){
	p=L,j=0;
	while(P&amp;&amp;j&lt;i-1){
		p=p-&gt;next+1;
		++j;
	}
	if(!p||j&gt;i-1){	//p为空-链表为空，j&gt;i-1查找完成后未找到元素
		return ERROR;
	}
	s=(LinkList)malloc(sizeof(LNode))//定义新的结点s
	s-&gt;data=e;		//新的结点的数据域赋值e
	s-&gt;next=P-&gt;next;	//新的指针域指向p的下一结点
	p-&gt;next=s;			//结点s与p相连
	return OK;
}
</code></pre><p><strong>代码</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Link {
    <span style="color:#66d9ef">int</span>  elem;
    <span style="color:#66d9ef">struct</span> Link <span style="color:#f92672">*</span>next;
}link;
<span style="color:#75715e">//无头结点链表的尾插法实现函数
</span><span style="color:#75715e"></span>link <span style="color:#f92672">*</span> <span style="color:#a6e22e">creatLink</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> arc, <span style="color:#66d9ef">int</span> length) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#75715e">//最初状态下，头指针 H 没有任何结点，所以，插入第一个元素，就相当于是创建结点 H
</span><span style="color:#75715e"></span>    link <span style="color:#f92672">*</span> H <span style="color:#f92672">=</span>(link<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(link));
    H<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>elem <span style="color:#f92672">=</span> arc[<span style="color:#ae81ff">0</span>];
    H<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> NULL;

    link <span style="color:#f92672">*</span> temp<span style="color:#f92672">=</span>H;
    <span style="color:#75715e">//如果采用尾插法插入超过 1 个元素，则需添加到链表表尾
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;</span>length; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        <span style="color:#75715e">//创建新结点并对其进行初始化
</span><span style="color:#75715e"></span>        link <span style="color:#f92672">*</span> a <span style="color:#f92672">=</span> (link<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(link));
        a<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>elem <span style="color:#f92672">=</span> arc[i];
        a<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> NULL;
        <span style="color:#75715e">//将新结点添加到链表的尾部
</span><span style="color:#75715e"></span>        temp<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> a;
        <span style="color:#75715e">//循环过程中，temp时刻指向链表中的最后一个结点
</span><span style="color:#75715e"></span>        temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next;
    }
    <span style="color:#66d9ef">return</span> H;
}
<span style="color:#75715e">//有头结点链表的尾插法实现函数
</span><span style="color:#75715e"></span>link <span style="color:#f92672">*</span> <span style="color:#a6e22e">HcreatLink</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> arc, <span style="color:#66d9ef">int</span> length) {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#75715e">//创建头结点 H，其链表的头指针也是 H
</span><span style="color:#75715e"></span>    link <span style="color:#f92672">*</span> H <span style="color:#f92672">=</span> (link<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(link));
    H<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>elem <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    H<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> NULL;
    <span style="color:#75715e">//设置一个指针，在遍历链表时用
</span><span style="color:#75715e"></span>    link <span style="color:#f92672">*</span> temp <span style="color:#f92672">=</span> H;
    <span style="color:#75715e">//采用尾插法创建链表
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>length; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        <span style="color:#75715e">//创建新结点并对其进行初始化
</span><span style="color:#75715e"></span>        link <span style="color:#f92672">*</span> a <span style="color:#f92672">=</span> (link<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(link));
        a<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>elem <span style="color:#f92672">=</span> arc[i];
        a<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> NULL;
        <span style="color:#75715e">//将新结点链接到链表的表尾
</span><span style="color:#75715e"></span>        temp<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> a;
        <span style="color:#75715e">//循环过程中，temp始终指向链表表尾的结点
</span><span style="color:#75715e"></span>        temp <span style="color:#f92672">=</span> temp<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next;
    }
    <span style="color:#66d9ef">return</span> H;
}
<span style="color:#75715e">//链表的输出函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">display</span>(link <span style="color:#f92672">*</span>p) {
    <span style="color:#66d9ef">while</span> (p) {
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, p<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>elem);
        p <span style="color:#f92672">=</span> p<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next;
    }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>};
    <span style="color:#75715e">//采用尾插法创建无头结点链表
</span><span style="color:#75715e"></span>    link <span style="color:#f92672">*</span> H <span style="color:#f92672">=</span> creatLink(a, <span style="color:#ae81ff">4</span>);
    display(H);
    <span style="color:#75715e">//采用尾插法创建有头结点链表
</span><span style="color:#75715e"></span>    link <span style="color:#f92672">*</span> head <span style="color:#f92672">=</span> HcreatLink(a, <span style="color:#ae81ff">4</span>);
    display(head);
    <span style="color:#75715e">//使用完毕后，释放即可
</span><span style="color:#75715e"></span>    free(H);
    free(head);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="heading23">删除操作</h4>
<pre><code>Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e){
	//此处e用于保存删除结点的数据域以便后面使用
	p=L;
	j=0;
	while(p-&gt;next&amp;&amp;j&lt;i-1){
		p=p-&gt;next;
		++j;
	}
	if(!(p-&gt;next)||j&gt;i-1){
		return ERROR;
	}
	q=p-&gt;next;	//q指向的是删除结点
	
	//p-&gt;next=p-&gt;next-&gt;next; 找到i结点，将i的前驱结点p的next域直接指向i的下一个（i+1）next域
	p-&gt;next=q-&gt;next;	//改变删除结点的前驱结点的指针域
	
	e=q-&gt;data;
	free(q);
	return OK;
	}
</code></pre><p>插入与删除时间复杂度</p>
<p>O(1) 线性表不需要移动元素，只需要修改指针</p>
<p>如果不知道插入删除位置，要从头开始查找前驱结点O(n)</p>
<h4 id="heading24">单链表的建立</h4>
<h5 id="heading25">头插法</h5>
<p>元素插入链表头部</p>
<p>algorithm analysis</p>
<ol>
<li>从一个空表开始，重复读入数据（倒位序）</li>
<li>生成新结点，将读入数据存放在新结点的数据域中</li>
<li>从最后一个结点开始，依次将各结点插入到链表的前端</li>
</ol>
<pre><code>void CreatList_H(LinkList &amp;L,int n){
	L=new LNode;
	L-&gt;next=NULL;
	for(i=n;i&gt;0;--i){
		p=new LNode;	//生成新结点接受数据
		/*
		analysis
		第一次插入，头节点指针域NULL传给新结点，结点p与头节点相连（第二行）
		第二次插入，L指针域指向的第一次插入时创造的新结点，断开此处，连接第二次插入创建的指针，完成后与L连接，（第三行）*/
		cin&gt;&gt;p-&gt;data;	
		p-&gt;next=L-&gt;next;	
		L-&gt;next=p;
	}
}
</code></pre><p><img src="http://data.biancheng.net/uploads/allimg/180426/2-1P426131350253.png#crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;id=EUycU&amp;originHeight=927&amp;originWidth=1032&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h5 id="heading26">尾插法</h5>
<p>algorithm analysis</p>
<p>正位序插入</p>
<pre><code>void CreatList _R(LinkList &amp;L,int n){
	L=new LNode;
	L-&gt;next=NULL;
	r=L;	//尾指针指向头节点
	fot(i=0;i&lt;n;i++){
		p=new LNode;
		p-&gt;next=NULL;	//define new node P,point to NULL
		r-&gt;next=p;	//connet node r and p,r next point to p
		r=p;	//after connet ,move r to p,make sure tail node=r
	}
}
</code></pre><p>O(n)</p>
<hr>
<h2 id="loop-linklist">Loop Linklist</h2>
<p>循环链表是一种头尾相连的链表（表中最后一个结点的指针域指向头节点，形成一个环）</p>
<p><strong>优点</strong>：从表中任一结点均可找到表中其他结点</p>
<p>循环链表中没有NULL指针，所以在遍历操作时，终止条件是判断它是否=头指针</p>
<table>
<thead>
<tr>
<th></th>
<th>单链表</th>
<th>循环单链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>判空条件：</td>
<td>p!-NULL</td>
<td>p!=L</td>
</tr>
<tr>
<td>循环条件</td>
<td>p-next!=NULL</td>
<td>p-&gt;next!=L</td>
</tr>
</tbody>
</table>
<p>表的操作常常在表的守卫位置上进行</p>
<p>链表合并</p>
<p>带尾指针循环链表合并</p>
<ol>
<li>p存表头结点（在连接过程中会被覆盖，要预先保存）</li>
</ol>
<pre><code>LinkList connect(LinkList Ta,LinkList Tb){
	p=Ta-&gt;next;
	Ta-&gt;next=Tb-&gt;next-&gt;next;
	delete Tb-&gt;next;
	Tb-&gt;next =p;
}
</code></pre><h2 id="heading27">双链表</h2>
<p>在单链表的每个节点里再增加一个指向其直接前驱的指针</p>
<p>头节点的prior，尾结点的next为NULL</p>
<table>
<thead>
<tr>
<th>prior</th>
<th>data</th>
<th>next</th>
</tr>
</thead>
</table>
<p><strong>定义</strong></p>
<pre><code>typedef struct DuLNode {
	Elemtype data;
	strcut DuLNode *prior,*next;
}DuLNode,*DuLinkList
</code></pre><h2 id="heading28">双向链表</h2>
<ul>
<li>让头节点 的前驱指针指向链表的最后一个结点</li>
<li>让最后一个结点的后记指针指向头指针</li>
</ul>
<p>双向链表结构的对称性</p>
<pre><code>p-&gt;prior-&gt;next = p = p-&gt;next-&gt;prior
</code></pre><p>插入删除操作时，需要同时修改两个方向上的指针</p>
<p><strong>双向链表的插入</strong></p>
<pre><code>void ListInsert_Dul(DuLinkList &amp;L,int i,ElemType e){
	if(!(p=GetElemP_Du(L,i)))	//在表中查找i位置
		return ERROR;
	s=new DuLNode;	//creat new node
	s-&gt;data=e;	//e赋值数据域
	s-&gt;prior=p-&gt;prior;
	p-&gt;prior-&gt;next=s;
	s-&gt;next=p;
	p-&gt;prior=s;
	
	return OK;
}
</code></pre><p><strong>双向链表的删除</strong></p>
<p>algorithm analysis</p>
<p>只要改变目标结点与前后元素的联系即可</p>
<pre><code>void Delete_DuL(DuLink &amp;L,int i,ElemType &amp;e){
	if(!(=GetElemP_DuL(L,i)))	return ERROR;
	e=p-&gt;data;
	P-&gt;prior-&gt;next=p-&gt;next;
	p-next-&gt;prior=p-&gt;prior;
	free(p);
	return OK;
}
</code></pre><p>时间复杂度</p>
<p>知道删除位置：O(1)</p>
<p>需要查找删除位子：O(n)</p>
<p>单链表，循环链表，双向链表的时间效率比较</p>
<table>
<thead>
<tr>
<th></th>
<th>查找表头结点（首元结点）</th>
<th>查找表尾结点</th>
<th>查找结点*P的前驱结点</th>
</tr>
</thead>
<tbody>
<tr>
<td>带头结点的<strong>单链表</strong>L</td>
<td>L-&gt;next    O(1)</td>
<td>从L-&gt;next向后遍历    O(n)</td>
<td>通过</td>
</tr>
<tr>
<td>tong</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<p><strong>顺序表和链表的比较</strong></p>
<p>链式存储结构的优点：</p>
<ul>
<li>节点空间可以动态申请和释放</li>
<li>数据元素的逻辑次序靠结点的指针来指示，插入和删除元素不需要移动数据元素</li>
</ul>
<p>链式存储结构的缺点：</p>
<ul>
<li>存储密度小，每个结点的指针域需额外占用存储空间，当每个结点的数据域所占字节不多时造成内存浪费
<ul>
<li>存储密度：结点数据本身 占用的空间/结点占用的空间总量</li>
</ul>
</li>
<li>链式存储结构是非随机存储结构。对任一结点的操作都要从头结点依指针链查找到该结点（增加算法复杂度</li>
</ul>
<hr>
<h2 id="heading29">线性表的应用</h2>
<p><strong>线性表的合并</strong></p>
<p>利用</p>
<p>La=（1，5，3，11） Lb=（2，6，3）</p>
<p>顺序表实现</p>
<p>链表实现</p>
<h2 id="heading30">练习</h2>
<p>删除单链表中最小元素</p>
<pre><code>/*
	删除表中最小值结点
	algorithm analysis
	定义一个mininum，遍历整个链表，找到比他大的就交换数值 
	在单链表删除一个结点要直到结点的前驱
	该前驱直接指向要删除结点的后继即可删除该结点
*/
void DelMinnode(LNode *L){
	 LNode *pre=L,*p=pre-&gt;next,*minp=p,*minpre=pre;
	 while(p!=NULL){
	 	if(p-&gt;data&lt;minp-&gt;data){
	 		minp=p;
	 		minpre=pre;
		 }
		 //移动 
		 pre=p;
		 p=p-&gt;next;
	 }
	 minpre-&gt;next=minp-&gt;next;
	 free(minp); 
}
</code></pre><p>栈和队列是限定插入和删除只能在表的端点进行的线性表</p>
<h1 id="stack">栈（Stack）</h1>
<p>由于栈的操作具有==后进先出(Last In First Out）==的固有特性，如果求解过程具有“后进先出”的天然特性，则求解算法时必须使用栈</p>
<ul>
<li>数制转化</li>
<li>括号匹配的检验</li>
<li>行编辑程序</li>
<li>迷宫求解</li>
<li>表达式求值</li>
<li>八皇后问题</li>
<li>函数调用</li>
<li>递归调用的实现</li>
</ul>
<h2 id="heading31">栈的操作</h2>
<p><strong>顺序栈的表示和实现</strong></p>
<p>空栈：base==top是栈空的标志</p>
<p>栈满：top-base==stacksize</p>
<p>使用数组作为顺序表存储方式的特点：
简单，方便，但容易产生溢出（数组大小固定）</p>
<p><strong>上溢（overflow）</strong>：栈已满，又要压入元素</p>
<p><strong>下溢（underflow）</strong>：栈已空，还要弹出元素</p>
<p><strong>顺序栈的表示</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">define MAXSIZE 100</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
	SElemType <span style="color:#f92672">*</span>base;
	SElemType <span style="color:#f92672">*</span>top;
	<span style="color:#66d9ef">int</span> stacksize;
}SqiStack;
</code></pre></div><p>顺序栈的初始化</p>
<pre><code>Status InitStack(SqStack &amp;S){
	S.base=new SElemType[MAXSIZE];	//C++
	S.base=(SElemType*)malloc(MAXSIZE*(乘）sizeof(SElemType));	//c
	
	if(!S.base) exit(OVERFLOW);
	S.top=S.base;
	S.stacksize=MAXSIZE;
	return OK;
}
</code></pre><p>顺序栈判空</p>
<pre><code>Status StackEmpty(SqStack S){
	if(S.top=S.base)
		return TRUE;
	else
		return FALSE;
}
</code></pre><p>顺序栈清空</p>
<pre><code>Status ClearStack(SqStack S){
	if(S.base) S.top=S.base;
	return OK;
}
</code></pre><p>顺序表销毁</p>
<pre><code>Status DestroyStack(SqStack &amp;S){
	if(S.base) {
	delete S.base;
	S.stacksize=0;
	S.top=S.base=NULL;
	}
	return OK;
}
</code></pre><p><strong>顺序栈的入栈</strong></p>
<ol>
<li>判断是否栈满，满则出错（上溢）</li>
<li>元素e压入栈顶</li>
<li>栈顶指针+1</li>
</ol>
<pre><code>Status Push(SqStack &amp;S,ElemType e){
	if(S.top-S.base=S.stacksize)	//栈满判断
		return ERROR;
	*s.top++=e; //or *S.top=e;
				//    S.top++;
	 retun OK;
}
</code></pre><p><strong>顺序栈的出栈</strong></p>
<ol>
<li>判断是否栈空，空则出错（下溢）</li>
<li>获取栈顶元素e</li>
<li>栈顶指针-1</li>
</ol>
<pre><code>Status Pop(SqStack &amp;s,SElemeType e){
	if(S.top==S.base)
		return ERROR;
	e=*--S.top;//指针减一，解引用出去指针的值赋给e
			   //or --S.top;
			   //   e=*S.top;
	return OK;
}
</code></pre><p>链栈的表示</p>
<p>链栈是运算受限的单链表，只能在链表头部进行操作</p>
<p><strong>链栈的定义</strong></p>
<pre><code>typedef struct StackNode{
	SElemType data;
	struct StackNode *next;
}StackNode,*LinkStack;
</code></pre><p>单链表中的指针域是an-an-1,在链栈中指针方向相反，因为插入与删除是在栈顶进行，这样的指针方向更方便。</p>
<ul>
<li>链表的头指针就是栈顶</li>
<li>不需要头结点</li>
<li>基本不存在栈满的清空</li>
<li>空栈相当于头指针指向空</li>
<li>插入与删除仅在栈顶处执行</li>
</ul>
<p>链栈的表示与实现</p>
<p>链栈的初始化</p>
<pre><code>void InitStack(LinkStack &amp;s){
	//构造一个空栈，栈顶指针置空
	S=NULL;
	return OK;
}
</code></pre><p>链栈判空</p>
<pre><code>Status StackEmpty(LinkStack S){
	if(S==NUll)
		return TRUE;
	else return FALSE;
}
</code></pre><p>链栈的入栈</p>
<pre><code>Status Push(linkStack &amp;s,SElemType e){
	p=new StackNOde;q	//creat new node
	p-&gt;data=e;
	p-&gt;next=s;
	S=p;//修改栈顶指针
	return OK；
}
</code></pre><p>链栈的出栈</p>
<pre><code>Status Pop(LinkStack &amp;S,SElemType &amp;e){
	if(s=NULL) return ERROR;
	e=S-&gt;data;
	p=S;
	S=S-&gt;next;
	delete p;
	return OK;
}
</code></pre><p>取栈顶元素</p>
<pre><code>SElemType GetTop(LinkStack S){
	if(S!=NULL)
		return S-&gt;date;
}
</code></pre><p>栈与递归</p>
<p><strong>递归</strong></p>
<p>若一个对象部分地包含它自己，或用它自己来给自己定义，则称这个对象是递归</p>
<p>若一个过程直接地或者间接地调用自己，则称这个过程是递归地过程</p>
<p>递归求n地阶乘</p>
<pre><code>long Fact(long n){
	if(n==0) return 1;
	else return n*Fact(n-1);
}
</code></pre><p>常用到递归方法的情况</p>
<ul>
<li>递归定义的数据函数
<ul>
<li>阶乘函数</li>
<li>Fibonacci数列</li>
</ul>
</li>
<li>具有递归特性的数据结构
<ul>
<li>二叉树</li>
<li>广义表</li>
</ul>
</li>
<li>可递归求解的问题
<ul>
<li>迷宫问题</li>
<li>hanoi  tower</li>
</ul>
</li>
</ul>
<p>递归问题-用分治法求解</p>
<p>分治法：对于一个较为复杂的问题，能够分解成几个相对简单且解法相同或者类似的子问题求解</p>
<p>必备的三个条件：</p>
<ol>
<li>能将一个问题转变成一个新的问题，而新的问题的解法相同或者类同，不同的仅是处理的对象，且这些处理对象是变化有规律的</li>
<li>可以通过上述转化而使问题简化</li>
<li>必须有一个明确的递归出口（递归边界）</li>
</ol>
<h2 id="heading32">表达式问题</h2>
<p>根据运算符的位置分为：前缀（波兰式），中缀，后缀（逆波兰式）表达式</p>
<p>转换方式</p>
<hr>
<h1 id="queue">队列（Queue）</h1>
<p>先进先出（First In First Out），头删尾插</p>
<p>案例分析</p>
<p><strong>进制转换</strong></p>
<p><strong>括号匹配检验</strong></p>
<p>左括号进栈，右括号判断当前栈顶元素是否匹配，成功就出栈，不成功输出不匹配</p>
<p><strong>表达式求值</strong></p>
<p>表达式求值是程序设计语言编译中最基本的问题，算法利用运算符优先级确定运算顺序，实现需要用栈</p>
<p>队列的顺序表示</p>
<pre><code>#define MAXQSIZE 100
Typedef struct{
	QElemType *base;
	int front;
	int rear;
}SqQueue;
</code></pre><p>队列的顺序表示与实现</p>
<p>顺序队列的假溢出问题</p>
<p>循环队列</p>
<p>循环队列的初始化</p>
<pre><code>Status InitQueue(SqQueue &amp;Q){
	Q.base=new QElemType[MAXQSIZE];//c++

	Q.base=(QElemType*)malloc(MAXSIZE*sizeof(QElemType));//c
	if(!Q.base) exit(OVERFLOW);	//存储分配失败
	Q.front=Q.rear=0;
}
</code></pre><p>循环队列的入队出队</p>
<pre><code>//入队
rear=(rear+1)%MAXSIZE;
queue[rear]=x;


//出队
front=(front+1)%MAXSIZE;
x=queue[front];
</code></pre><p>**队满：**front ==（rear+1)&amp;MAXSIZE;</p>
<p>链队</p>
<h2 id="heading33">输出序列问题</h2>
<p>catelent</p>
<h1 id="string">串String</h1>
<p>内容受限的线性表</p>
<p>串-零个或多个任意字符组成的有限序列</p>
<p><strong>子串</strong>：</p>
<p>串的类型定义</p>
<p><strong>串的顺序存储结构</strong></p>
<p>定长顺序存储表示</p>
<pre><code>typedef struct{
	char str[MAXSIZE+1];
	int length;
}Str;
</code></pre><p>边长顺序存储</p>
<pre><code>typedef struct{
	char *ch；
	int length;
}str;
//定义变量
Str S;
s.length=L;
S.ch=(char*)malloc((L+1)*sizeof(char)) //malloc返回空间首地址
</code></pre><p>现实中对串的插入和删除较少，只进行一些匹配查找运算。所以顺序存储结构使用较多</p>
<p><strong>串的链式存储结构</strong></p>
<p>为了提高存储效率，将多个字符放在一个结点中</p>
<p>块链存储结构</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#</span><span style="color:#75715e">define CHUNKSIZE 80 </span><span style="color:#75715e">//块的大小由用户定义
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Chunk{
	<span style="color:#66d9ef">char</span> ch[CHUNKSIZE];
	<span style="color:#66d9ef">struct</span> Chunk <span style="color:#f92672">*</span>next;
}Chunk;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
	Chunk <span style="color:#f92672">*</span>head,<span style="color:#f92672">*</span>tail;	<span style="color:#75715e">//串的头指针和尾指针
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> curlen;			<span style="color:#75715e">//串的当前长度
</span><span style="color:#75715e"></span>}LString
</code></pre></div><p>串的基本操作</p>
<p><strong>赋值操作</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">strAssign</span> (Str<span style="color:#f92672">&amp;</span> str,<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> ch){
	<span style="color:#66d9ef">if</span>(str.ch)	<span style="color:#75715e">//ch为NULL,不执行free操作，不为NULL，值为真则释放ch空间
</span><span style="color:#75715e"></span>		free(str.ch)
	<span style="color:#66d9ef">int</span> length<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c<span style="color:#f92672">=</span>ch;
	
	<span style="color:#66d9ef">while</span>(<span style="color:#f92672">*</span>c){
		<span style="color:#f92672">+</span><span style="color:#f92672">+</span>length;
		<span style="color:#f92672">+</span><span style="color:#f92672">+</span>c;
	}
	<span style="color:#75715e">//传入空串赋值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(lenght<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>){
		str.ch<span style="color:#f92672">=</span>NULL;
		str.length<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
	}<span style="color:#66d9ef">else</span>{
		Str.ch<span style="color:#f92672">=</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)malloc((length<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>));
		<span style="color:#75715e">//内存满，空间分配失败
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(str.ch<span style="color:#f92672">=</span>NULL)
			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">else</span>{
			c<span style="color:#f92672">=</span>ch;
			<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>length;<span style="color:#f92672">+</span><span style="color:#f92672">+</span>i,<span style="color:#f92672">+</span><span style="color:#f92672">+</span>c)
				str.ch[i]<span style="color:#f92672">=</span><span style="color:#f92672">*</span>c;
			str.length<span style="color:#f92672">=</span>length;
			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
		}
	}
}
</code></pre></div><p><strong>串的模式匹配算法</strong></p>
<p>算法目的：确定主串中所含子串（模式串）第一次出现的位置</p>
<p>算法应用：搜索引擎，拼写检查，语言翻译，数据压缩</p>
<p><strong>算法种类：</strong></p>
<ul>
<li>BF算法（Brute-Force 穷举法）</li>
<li>KMP算法</li>
</ul>
<p>BF算法</p>
<p>算法思路：从主串的每一个字符开始依次与子串的字符进行匹配</p>
<p>将主串的第pos个字符和模式串的第一个字符比较</p>
<ul>
<li>相等，继续逐个比较后续字符</li>
<li>不等，从主串的1下一个字符起，重新与模式串的第一个字符比较</li>
<li>直到主串都一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，及批评成功</li>
<li>否则，匹配失败，返回0</li>
</ul>
<pre><code>int Index_BF(SString S,SString T){
	int i=1,j=1;
	while(i&lt;=S.length&amp;&amp;j&lt;=T.length){
		if(s.ch[i]==t.ch[j]){++i;++j}
		else {i=i-j+2;j+1;}
	}
	if(j&gt;T.length) return i-T.length;
	else return 0;
}
</code></pre><p>On：最好情况循环比较子串长度M，最差情况每次匹配到子串最后一位才不匹配，即每次都要M次才发现不匹配。总共要匹配n-m个位置（即n-m位比较了m次），最后M位也各比较一次。总次数(n-m)*m+m=(n-m+1)m,若m&laquo;n, Onm</p>
<p>KMP算法</p>
<h1 id="heading34">数组</h1>
<p>按一定格式排列起来的具有相同类型的数据元素的集合</p>
<p><strong>声明格式</strong>：数据类型 变量长度[长度]	例如：int num[5]={0,1,2,3,4}</p>
<p>在C语言中，一个二维数组类型也可以定义为一维数组类型（其分量类型为一维数组类型）</p>
<pre><code>typedef elemetype array2[m][n]
等价于
typedef elemetype array1[n];
typedef array1 array2[m];
</code></pre><p>线性表结构是数组结构的一个特例，而数组结构又是线性表结构的拓展</p>
<p>数组特点：结构固定——定义后，维数和维界不再改变</p>
<p><strong>数组的顺序存储</strong></p>
<p>因为数组的特点，以及一般不做插入和删除操作。所以多为顺序储存结构</p>
<h1 id="heading35">矩阵</h1>
<p>对称矩阵</p>
<p>三角矩阵</p>
<h2 id="heading36">稀疏矩阵</h2>
<p>稀疏矩阵的顺序存储结构</p>
<p>三元组顺序表</p>
<p>稀疏矩阵的链式存储结构</p>
<p>十字链表</p>
<hr>
<h1 id="heading37">广义表</h1>
<p>是一种递归定义</p>
<h1 id="tree">树Tree</h1>
<p>树型结构（非线性结构）</p>
<ul>
<li>结点之间有分支</li>
<li>具有层次关系</li>
</ul>
<p><strong>树的基本术语</strong></p>
<ul>
<li>结点&mdash;-数据元素以及指向子树的分支
<ul>
<li>根结点&mdash;-非空树中的无前驱结点的结点</li>
</ul>
</li>
<li>结点的度&mdash;-结点拥有的子树数
<ul>
<li>树的度：树内各结点的度的最大值</li>
<li>度=0，叶子（终端节点）。度!=0分支结点。根结点以外的分支节点&mdash;-内部节点</li>
</ul>
</li>
<li>孩子&mdash;-结点的子树的根
<ul>
<li>该结点称为孩子的双亲</li>
</ul>
</li>
</ul>
<h2 id="heading38">二叉树</h2>
<p><strong>二叉树与树的最主要的差别</strong></p>
<p>二叉树结点的子树要区分左子树和右子树，即使只有一颗子树也区分左，右子树</p>
<p>树当结点只有一个孩子时，就无须区分它是左还是右的次序。</p>
<p>二叉树的每个结点的位置都是固定的，可以是空，但不可以说它没有位置。而树的节点位置相对于别的结点来说，没有别的结点时，就无所谓左右</p>
<p><strong>二叉树的五种基本形态</strong></p>
<ol>
<li>空二叉树</li>
<li>根与空的左右二叉树</li>
<li>根与左子树</li>
<li>根与右子树</li>
<li>根与左右子树</li>
</ol>
<p>二叉树的建立</p>
<p>空结点用” # “表示</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">Status <span style="color:#a6e22e">CreateBiTree</span>(BiTree <span style="color:#f92672">&amp;</span>T){
    scanf(<span style="color:#f92672">&amp;</span>ch);
    <span style="color:#66d9ef">if</span>(ch<span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">#</span><span style="color:#e6db74">&#34;</span>) <span style="color:#66d9ef">return</span> T<span style="color:#f92672">=</span>NULL;
    <span style="color:#66d9ef">else</span>{
        <span style="color:#66d9ef">if</span>(T<span style="color:#f92672">=</span>(BiTree<span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(BiTNode)))
    }
}
</code></pre></div><h2 id="heading39">二叉排序树</h2>
<p><strong>二叉排序树的特性</strong></p>
<ul>
<li>左子树非空，则左子树上所有节点的值都小于根节点的值</li>
<li>右子树非空，则右子树上所有节点的值都大于于根节点的值</li>
<li>左右子树分别是一棵二叉排序树</li>
</ul>
<p>根究其特点，对二叉排序树进行中序遍历，就能得到一个递增有序序列</p>
<p><strong>二叉排序树的非递归查找算法</strong></p>
<ol>
<li>若二叉排序树非空，将根节点与查找数比较，相等则查找成功</li>
<li>若小于根节点的值，进入根节点的左子树</li>
<li>若大于根节点的值，进入根节点的右子树</li>
<li>根节点为空</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">BSTNode <span style="color:#f92672">*</span><span style="color:#a6e22e">BST_search</span>(BiTress T,ElemType key){
    <span style="color:#66d9ef">while</span>(T<span style="color:#f92672">!</span><span style="color:#f92672">=</span>NUll<span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span>key<span style="color:#f92672">!</span><span style="color:#f92672">=</span>T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data){ <span style="color:#75715e">//when T-&gt;data=key and T=NULL,out of loop
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(key<span style="color:#f92672">&lt;</span>L<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data)
            T<span style="color:#f92672">=</span>T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>Lchild;
        <span style="color:#66d9ef">else</span>
            T<span style="color:#f92672">=</span>T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>Rchild;
    }
    <span style="color:#66d9ef">return</span> T;
}
</code></pre></div><p><strong>二叉排序树的插入节点算法</strong></p>
<ol>
<li>二叉排序树为空，直接插入结点</li>
<li>若插入值小于根节点的值，则进入根节点的左子树</li>
<li>若插入值大于根节点的值，则进入根节点的右子树</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BST_Insert</span>(BiTree <span style="color:#f92672">&amp;</span>T,ElemType key){	<span style="color:#75715e">//要对原二叉排序树进行修改，使用引用型
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(T<span style="color:#f92672">=</span><span style="color:#f92672">=</span>NULL){
        <span style="color:#75715e">//要在二叉排序树中插入插入元素，其实就是找到元素的合适位置（叶子节点）
</span><span style="color:#75715e"></span>        
		T<span style="color:#f92672">=</span>(BiTree)malloc(<span style="color:#66d9ef">sizeof</span>(BSTNode));
        T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>Lchild<span style="color:#f92672">=</span>T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>Rchild<span style="color:#f92672">=</span>NULL;
        T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data<span style="color:#f92672">=</span>key;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;	<span style="color:#75715e">//Insert success
</span><span style="color:#75715e"></span>	}<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(K<span style="color:#f92672">=</span><span style="color:#f92672">=</span>T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(key<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>data)
        <span style="color:#66d9ef">return</span> BST_Insert(T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>Lchild,K);
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> BTS_Insert(T<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>Rchild,k);
}
</code></pre></div><p><strong>二叉排序树的构造</strong></p>
<p>基于二叉排序树的插入算法，一个个插入节点</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Creat_BST</span>(BiTree <span style="color:#f92672">&amp;</span>T,ElemType str[],<span style="color:#66d9ef">int</span> n){
	T<span style="color:#f92672">=</span>NULL;
	<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>n){
        BST_Insert(T,str[i]);<span style="color:#75715e">//将数组中每个元素依次插入
</span><span style="color:#75715e"></span>        i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
    }
}
</code></pre></div><p><strong>二叉树的删除操作</strong></p>
<ul>
<li>删除的是叶子结点
<ul>
<li>修改双亲结点指针域中相应值为空</li>
</ul>
</li>
<li>删除的节点只有左子树或右子树，用其左子树或右子树替换
<ul>
<li>双亲节点的相应指针的值改为“指向被删除结点的左子树或右子树</li>
</ul>
</li>
<li>删除节点既有左子树，又有右子树
<ul>
<li>以其中序前驱值替换之，然后再删除该前驱结点（前驱是左子树中最大的结点）</li>
<li>或者，用其后继替换之，然后再删除该后继节点（后继是右子树中最小的结点）</li>
</ul>
</li>
</ul>
<p><strong>二叉排序树的查找</strong></p>
<p>含有n各结点二叉排序树的平均查找长度和树的形态有关</p>
<p>最好情况（形态比较均衡）：ASL=log2(n+1)-1	O(log2n)</p>
<p>最坏情况（单支树的形态）：ASL=(n+1)/2</p>
<p>为了提高形态不均衡的二叉排序树的查找效率，”平衡化“</p>
<h2 id="heading40"><strong>平衡二叉树</strong></h2>
<p>性质：</p>
<ol>
<li>任意一个树的左右子树高度差的绝对值&lt;=1</li>
<li>左右子树也是平衡二叉树</li>
</ol>
<h3 id="heading41"><strong>失衡二叉树的分析与调整</strong></h3>
<p>调整原则</p>
<ol>
<li>降低高度</li>
<li>保持二叉排序树的性质</li>
</ol>
<p>先找最小失衡节点</p>
<p><strong>LL平衡</strong></p>
<p>结点插入位置为</p>
<p><strong>RR型调整</strong></p>
<p><strong>LR型调整</strong></p>
<p>c结点穿过a，b节点上</p>
<p>b结点成为c的左孩子，a结点成为c的右孩子</p>
<p>原来c节点的左子树作为b的右子树</p>
<p>原来c的右子树作为a的左子树</p>
<p><strong>RL型调整</strong></p>
<p>RL型调整，结点插入位置为其右孩子的左子树，如图所示插入结点8失衡，</p>
<p>处理方法：找到RL型的中间结点，本例中是9，让他取代根节点7的位置，7小于9成为9的左子树，11大于9成为右子树。</p>
<p>对原来9的左右结点分析，8插入位置是根究结点大小分布决定的，8大于7即决定了它只能在7的右边，所以插入7的右子树。对于插入结点是10的情况，10小于11结点即只能在结点11的左边，所以插入左子树</p>
<h2 id="huffman-tree">哈夫曼树（Huffman Tree）</h2>
<p>哈夫曼树的构建</p>
<h1 id="heading42">图</h1>
<h2 id="heading43">图的储存结构</h2>
<h3 id="heading44">领阶矩阵&ndash;顺序存储</h3>
<p><strong>无向图</strong></p>
<p>建立一个顶点表（一个一维数组记录各个顶点信息），一个领阶矩阵（一个二维矩阵存储图中变得信息）</p>
<p>有那个元素就用一个nxn矩阵来表示图</p>
<p>A[i] [j]=1，表示顶点i与j相连</p>
<p>A[i] [j]=0，表示顶点i与j不相连</p>
<p>无向图的领接矩阵是对称的</p>
<p>顶点i的度=第i行（列）中1的个数</p>
<p><strong>有向图</strong></p>
<p>有向图的领阶矩阵可能不对称</p>
<p>第i行：结点Vi的出度边</p>
<p>第i列：结点Vi的入度边</p>
<p>顶点出度：第i行元素之和</p>
<p>顶点入度：第i列元素之和</p>
<p>顶点的度=出度+入度</p>
<p><strong>网（有权图）</strong></p>
<p>领接矩阵存储结构定义</p>
<h3 id="heading45">领接表</h3>
<p>特点</p>
<ul>
<li>顶点的出度为第i个单链表中的结点个数</li>
<li>顶点的入度是整个单链表中领接点域值的i-1的结点个数</li>
<li>方便找任意顶点的所有”邻接点“</li>
<li>节约稀疏图的空间
<ul>
<li>需要N个头指针，2E个结点（每个结点至少2个域）</li>
</ul>
</li>
</ul>
<p>对于无向图，方便计算任一顶点的度，可对于有向图，只能计算”出度“，需要构造逆邻接表（存指向自己的边，来方便计算”入度）</p>
<p>总结：找出度容易，找入度难</p>
<p><strong>邻接矩阵与邻接表的关系</strong></p>
<p>联系：邻接表中每个链表对应于邻接表中的一行，链表中结点个数=一行中非零元素的个数</p>
<p>区别：对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（邻接表与顶点编号无关，与插入算法有关）邻接矩阵空间复杂度O（n2),邻接表是O(n+e),所以对于稀疏图来说邻接表效率更高，邻接矩阵多用于稠密图</p>
<p><strong>逆领接表</strong></p>
<p>找入度容易，找出度难</p>
<p>当领接表的存储结构形成后，图便唯一确定</p>
<h2 id="heading46">图的遍历</h2>
<h3 id="dfs">深度优先搜索遍历DFS</h3>
<p>邻接矩阵表示的无向图深度遍历实现</p>
<pre><code>void DFS (AMGraph G,int v){
	cout&lt;&lt;v;visited[v]=true;
	for(w=0;w&lt;G.vexnum;w++){
		if((G.arcs[v][w]!=0)&amp;&amp;(!visited[w])){
		DFS(G,w)
		}
	}
}
</code></pre><p>用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行O(n2)</p>
<h3 id="bfs">广度优先搜索遍历BFS</h3>
<p>DFS 与 BFS算法效率比较</p>
<p>空间复杂度相同，都是O(n)(借用来堆栈或队列)</p>
<p>时间复杂度只与存储结构（邻接矩阵或邻接表）有关，与搜索路径无关</p>
<h2 id="heading47">最小生成树</h2>
<p>MST性质</p>
<h3 id="prim">prim算法（普利姆）</h3>
<p>算法思想</p>
<ul>
<li>设N=(V,E)是连通网，TE是N上最小生成树中边的集合</li>
<li>初始设U={u0}，u0属于V，（从点顶点集合中任选一个顶点）TE={}</li>
<li>在所有的u属于U，v属于V-U的边(U,V)属于E中，找到一条代价最小的边(u0,V0)
<ul>
<li>在选出的顶点与其他顶点之间找到一条权值最小的表，加入最小生成树的边集合。连接的新结点也加入U集合</li>
</ul>
</li>
<li>将(u0,V0)并入TE，同时V0并于U</li>
<li>重复以上操作直至U=V，T=(V，TE)为最小生成树</li>
</ul>
<h3 id="kruskal">kruskal克鲁斯卡尔算法</h3>
<p>算法思想</p>
<p>设连通网</p>
<p>贪心算法</p>
<p>局部最优，达成整体最优</p>
<h2 id="heading48">最短路径</h2>
<p>Dijkstra迪杰斯特拉算法</p>
<p>Floyd弗洛伊德算法</p>
<h1 id="heading49">排序</h1>
<h2 id="heading50">快速排序</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quicksort</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> low,<span style="color:#66d9ef">int</span> hight){
	<span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> hight) {
		<span style="color:#66d9ef">int</span> pivotpos <span style="color:#f92672">=</span> partition(A, low, hight);
		quicksort(A, low, pivotpos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
		quicksort(A, pivotpos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, hight);
	}
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">show</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> n){
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span>n;i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>){
		printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>,A[i]);
	}
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span>(<span style="color:#66d9ef">int</span> A[],<span style="color:#66d9ef">int</span> low,<span style="color:#66d9ef">int</span> hight){
	<span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> A[low];
	<span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> hight) {
		<span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> hight <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> A[hight] <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> pivot)
			<span style="color:#f92672">-</span><span style="color:#f92672">-</span>hight;
		A[low] <span style="color:#f92672">=</span> A[hight];
		
		<span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> hight <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> A[low] <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> pivot)
			<span style="color:#f92672">+</span><span style="color:#f92672">+</span>low;
		A[hight] <span style="color:#f92672">=</span> A[low];
	}
	A[low] <span style="color:#f92672">=</span> pivot;
	
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>;i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>){
		printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>,A[i]);
	}
	printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	<span style="color:#66d9ef">return</span> low;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#66d9ef">int</span> A[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">53</span>,<span style="color:#ae81ff">67</span>,<span style="color:#ae81ff">75</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">84</span>,<span style="color:#ae81ff">74</span>,<span style="color:#ae81ff">23</span>};
	quicksort(A, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">7</span>);
	show(A, <span style="color:#ae81ff">7</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>堆排序</p>
<hr>
<h1 id="heading51">查找</h1>
<hr>
<h3 id="hash-table">Hash Table</h3>
<p>冲突</p>
<p>关键字</p>
<h2 id="hash-function"><strong>构造hash function的方法</strong></h2>
<p>除留余数法</p>
<h2 id="heading52">解决冲突问题</h2>
<p>二次探测法</p>
<h1 id="leetcode">leetcode代码笔记</h1>
<h2 id="leetcode-base">LeetCode base</h2>
<p>删除链表中倒数第n个结点</p>
<p>所谓「快慢指针」是指设定两个指针，其中快的指针的移动速度是慢的指针的移动速度的两倍；“快慢指针”方法主要用来解决两类问题，即“判断一个链表是否为循环链表”以及“寻找一个有序链表的中位数</p>
<p>双指针应用</p>
<p>rotate array</p>
<h2 id="heading53">哨兵结点问题</h2>
<h1 id="computer-english">Computer English</h1>
<p>递归——recursive</p>
<p>迭代——iterative</p>
<p>循环</p>
<p>单链表</p>
<p>顺序表哦</p>
<p>专业术语</p>
<p>线性表</p>
<p>栈与队列</p>

      </article>
    </section>

    
    <article class="ui segment post-disqus-area" data-html2canvas-ignore>
      <div id="disqus_thread"></div>
<script>
  


  var disqus_config = function () {
    this.page.url = "https://felixhjx.github.io/posts/dateconstruct/" 
    this.page.identifier = "/posts/dateconstruct/" 
  }

  ;(function () {
    
    var d = document,
      s = d.createElement('script')
    s.src = 'https://' + "felixhe" + '.disqus.com/embed.js'
    s.setAttribute('data-timestamp', +new Date())
    ;(d.head || d.body).appendChild(s)
  })()
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    </article>
    

    
    <article class="ui segment utterances-comments" data-html2canvas-ignore>
      <script
        src="https://utteranc.es/client.js"
        repo="felixhjx/felixhjx.github.io"
        issue-term="og:title"
        theme="github-light"
        crossorigin="anonymous"
        async>
      </script>
    </article>
    

    
  </div>
</div>


            <footer class="ui basic center aligned segment" style="background-color: transparent;">
              
              <p>© 2020 - 2022 hjxblog</p>
              

              <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</p>

              
            </footer>
          </div>
        </section>
        <section class="back">
          <div class="dream-max-width">
            <header class="ui basic very padded segment dream-header">
  
  <div class="ui small circular image">
    <img src="/me/yyhjx.jpg" alt="avatar" />
  </div>
  

  <div class="content">
    <h1 class="ui medium header">hjxblog<span class="sub header">Stay hungry, stay foolish!</span>
    </h1>

    <article class="ui horizontal list">
      
      <a class="item" href="/posts">
        <i class="archive icon" title="归档"></i>
      </a>
      
      <a class="item" href="/categories">
        <i class="th list icon" title="所有分类"></i>
      </a>
      <a class="item" href="/tags">
        <i class="tags icon" title="所有标签"></i>
      </a>
    </article>

    
    
    
    
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    

    

    
    
    
          <div class="dream-tags">
          
          
          
            <a class="ui label" href="/tags/blog/" title="blog">
              blog
            </a>
          
          
          
            <a class="ui label" href="/tags/computer_visual/" title="computer_visual">
              computer_visual
            </a>
          
          
          
            <a class="ui label" href="/tags/dataconstruct/" title="dataconstruct">
              dataconstruct
            </a>
          
          
          
            <a class="ui label" href="/tags/framework/" title="framework">
              framework
            </a>
          
          
          
            <a class="ui label" href="/tags/gradient_descent/" title="gradient_descent">
              gradient_descent
            </a>
          
          
          
            <a class="ui label" href="/tags/machine-learning/" title="machine learning">
              machine learning
            </a>
          
          
          
            <a class="ui label" href="/tags/mysql/" title="mysql">
              mysql
            </a>
          
          
          
            <a class="ui label" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">
              设计模式
            </a>
          
          </div>
    

    
  </div>
</header>


<div class="ui relaxed grid dream-grid dream-back">
  
  
  

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article class="ui segment">
      <div class="ui medium header">社交链接</div>
      <nav class="ui secondary menu dream-menu dream-socials">
  
  <a class="item" href="/index.xml">
    <i class="large rss square icon" title="RSS"></i>
  </a>
  

  
  <a class="item" href="mailto:15501975559@163.com">
    <i class="large mail icon" title="Email"></i>
  </a>
  

  

  

  

  

  

  

  

  

  
  
  
    <a class="item" href="https://instagram.com/hehjx97" target="_blank">
      <i class="large instagram icon" title="Instagram"></i>
    </a>
  
    <a class="item" href="https://github.com/felixhjx" target="_blank">
      <i class="large github icon" title="GitHub"></i>
    </a>
  
    <a class="item" href="https://stackoverflow.com/users/18233633/felixhjx" target="_blank">
      <i class="large stack overflow icon" title="stack overflow"></i>
    </a>
  
  
</nav>

    </article>
  </div>

  <div class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    
    <article class="ui segment">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。<br /><br />背景使用了 <a href="https://www.pexels.com/zh-cn/" target="_blank">Pexels</a> 上 <a href="https://www.pexels.com/zh-cn/@minan1398" target="_blank">Min An</a> 拍摄的<a href="https://www.pexels.com/zh-cn/photo/1454794/" target="_blank">图片</a>。
    </article>
    
  </div>

  
</div>

          </div>
        </section>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js" integrity="sha256-CgSoWC9w5wNmI1aN8dIMK+6DPelUEtvDr+Bc2m/0Nx8=" crossorigin="anonymous"></script>

    
    <div class="ui segment" id="dream-search">
  <div class="ui search">
    <div class="ui transparent input">
      <input class="prompt" type="text" placeholder="搜索" />
    </div>
    <div class="results"></div>
  </div>
</div>
<script>
  $(document).ready(function () {
    $.getJSON('https:\/\/felixhjx.github.io\//index.json', function (data) {
      $('.ui.search').search({
        source: data,
        searchFields: ['title'],
        showNoResults: false,
      })
    })
  })
</script>
<script src="/js/search.js"></script>

    

    

    <script>
  window.background = "#fff"
  window.defaultDark =  null 
  window.backgroundDark = "#333"
  window.backgroundImageDark = "/me/background1.jpg"
  window.darkNav =  null 
  window.maxTags =  null 
  window.hasTwitterEmbed =  null 
  window.fixedNav =  true 

  if (window.hasTwitterEmbed) {
    
    window.twttr = (function (d, s, id) {
      var js,
        fjs = d.getElementsByTagName(s)[0],
        t = window.twttr || {}
      if (d.getElementById(id)) return t
      js = d.createElement(s)
      js.id = id
      js.src = 'https://platform.twitter.com/widgets.js'
      fjs.parentNode.insertBefore(js, fjs)

      t._e = []
      t.ready = function (f) {
        t._e.push(f)
      }

      return t
    })(document, 'script', 'twitter-wjs')
  }
</script>
<script src="https://cdn.jsdelivr.net/npm/overlayscrollbars@1.13.1/js/jquery.overlayScrollbars.min.js" integrity="sha256-tBd38uWlvgfps3zHPrUb2ePBg+Z8EjMf0QloFONzpvU=" crossorigin="anonymous"></script>
<script src="/js/header.js"></script>
<script src="/js/main.js"></script>
<script src="/js/theme.js"></script>

    


<script src="https://cdn.jsdelivr.net/npm/luxon@1.26.0" integrity="sha256-4sbTzmCCW9LGrIh5OsN8V5Pfdad1F1MwhLAOyXKnsE0=" crossorigin="anonymous"></script>
<script>
  format()

  function format() {
    $('span[data-format="luxon"]').each(function () {
      var date = $(this).text()

      $(this).text(luxon.DateTime.fromISO(date, { locale: "zh" }).toFormat("yyyy年MM月dd日"))
    })
  }
</script>



<script src="/js/scrollToTop.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/highlight.min.js"></script>



<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/clojure.min.js"></script>

<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/languages/ocaml.min.js"></script>



<script>
  hljs.highlightAll()
  setHighlightTheme()

  function setHighlightTheme() {
    var isDark = localStore.getItem('hugo-theme-dream-is-dark')
    isDark = isDark ? isDark : window.defaultDark ? 'y' : isDark

    var lightTheme = "tomorrow"
    var darkTheme = "tomorrow-night"
    var theme = isDark === 'y' ? darkTheme : lightTheme

    $('link[data-highlight]').attr('href', 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/' + theme + '.min.css')
    $('pre').css('background', isDark === 'y' ? '#333' : '')
  }
</script>



<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.0.0-rc.1/dist/html2canvas.min.js" integrity="sha256-uacRffSSMP9qpvNWhVmYLykBv9YKMA1d/VSIN1AmfyQ=" crossorigin="anonymous"></script>
<script src="/js/post.js" defer></script>


    

    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-98295641-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
  </body>
</html>
